import { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';
export declare class AuthorizedApiBase {
    protected accessToken: string;
    private readonly config;
    protected constructor(config: IConfig, accessToken?: string);
    protected transformOptions: (options: AxiosRequestConfig) => Promise<AxiosRequestConfig>;
    setToken(accessToken: string): void;
}
export interface IFilesApiClient {
    /**
     * Login
     * @param body Required object for login request
     * @return successful operation
     */
    loginUser(body: Login, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<AccessRefreshTokens>;
    /**
     * Service Identity Token Generation
     * @param body (optional)
     * @return successful operation
     */
    generateServiceIdentityToken(body?: ServiceIdentityTokenRequest | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<IdentityToken>;
    /**
     * User Profile
     * @return successful operation
     */
    getUser(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<User>;
    /**
     * Update User Profile
     * @param body Updated user object
     * @return Successful Operation
     */
    updateUser(body: UserPatch, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<User>;
    /**
     * Link Identity Account to User Profile
     * @param body Updated user object with new identity account
     * @return Successful Operation
     */
    linkProfileUser(body: LinkRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<User>;
    /**
     * Unlink Identity Account from User Profile
     * @param body Updated user object by removing identity account
     * @return Successful Operation
     */
    unlinkProfileUser(body: IdentityProvider, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<User>;
    /**
     * Email Verify
     * @return successful operation
     */
    getEmailVerify(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    /**
     * New Email Verify Link
     * @param body Updated user object
     * @return Successful Operation
     */
    postNewEmailVerify(body: VerifyEmailToken, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    /**
     * Refresh Token
     * @param body (optional)
     * @return successful operation
     */
    getRefreshToken(body?: RefreshRequest | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<AccessRefreshTokens>;
    /**
     * Get Identity Web3 Token
     * @param public_address Public Address that will be associated with the user identity
     * @return Successful Operation
     */
    getIdentityWeb3Token(public_address: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<IdentityToken>;
    /**
     * Verify Web3 Identity
     * @param body (optional)
     * @return Successful Operation
     */
    postIdentityWeb3Token(body?: Web3RequestToken | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<IdentityToken>;
    /**
     * Get Identity Email token
     * @param body (optional)
     * @return Successfully send email
     */
    getIdentityEmailToken(body?: EmailIdentityRequestToken | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    /**
     * Verify Email Identity
     * @param body (optional)
     * @return Successful Operation
     */
    postIdentityEmailToken(body?: EmailIdentityVerifyToken | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<IdentityToken>;
    /**
     * Verify tKey Identity
     * @param body (optional)
     * @return Successful Operation
     */
    verifyServiceIdentityToken(body?: ServiceIdentityVerifyRequest | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<AccessRefreshTokens>;
    /**
     * Sets Master password flag
     * @param body (optional)
     * @return Successful Operation
     */
    secure(body?: SecureRequest | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    /**
     * Create New Access Key and Secret Pair for the user
     * @param body Create Access Key request body
     * @return Successful Operation
     */
    createAccessKey(body: CreateAccessKeyReq, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<AccessKey>;
    /**
     * Get all the access keys for the user
     * @return Successful Operation
     */
    listAccessKeys(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<AccessKey[]>;
    /**
     * Update access key
     * @param id The access key id to be updated
     * @param body (optional)
     * @return Successful Operation
     */
    updateAccessKey(id: string, body?: AccessKeyUpdate | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    /**
     * Delete an access key
     * @param id The access key id to be updated
     * @return Successful Operation
     */
    deleteAccessKey(id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    /**
     * Look up user's sharing details
     * @param username (optional) username of user
     * @param public_address (optional) public address of user
     * @param identity_public_key (optional) identity public key of user
     * @return User found
     */
    lookupUser(username?: string | undefined, public_address?: string | undefined, identity_public_key?: string | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<LookupUser>;
    /**
     * Abuse Users
     * @return successful operation
     */
    abuseUser(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<string[]>;
    /**
     * Get User Local Store
     * @return successful operation
     */
    getUserLocalStore(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<{
        [key: string]: string;
    }>;
    /**
     * Update User Local Store
     * @param body Updated user local store
     * @return Successful Operation
     */
    updateUserLocalStore(body: {
        [key: string]: string;
    }, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<{
        [key: string]: string;
    }>;
    /**
     * Delete User Local Store
     * @return Successful Operation
     */
    deleteUserLocalStore(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<{
        [key: string]: string;
    }>;
    /**
     * check the eligibility of the user for billing
     * @return Successful Operation
     */
    getEligibility(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<EligibilitiesResponse>;
    /**
     * Get the invoices related to user and subscription
     * @param subscription_id the subscription id for which invoices are to be fetched
     * @param size (optional) the number of invoices to return in the response
     * @param last_id (optional) the last_id parameter sent by the previous response. It will be used in pagination. you can skip it in first request.
     * @return Successful Operation
     */
    getAllInvoices(subscription_id: string, size?: number | undefined, last_id?: string | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<InvoicesResponse>;
    /**
     * pay an invoice
     * @param id identification number of the invoice
     * @return Successful Operation
     */
    payInvoice(id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<InvoiceResponse>;
    /**
     * download invoice pdf
     * @param id identification number of the invoice
     * @return Successful Operation
     */
    downloadInvoice(id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<FileResponse>;
    /**
     * Get All available products for a product/service
     * @return Successful Operation
     */
    getAllProducts(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<Product[]>;
    /**
     * Get All purchased products for a user
     * @return Successful Operation
     */
    getPurchasedProducts(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<PurchasedProductResponse[]>;
    /**
     * Get a pricing product
     * @param id identification number of the product
     * @return Successful Operation
     */
    getPlan(id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<Product>;
    /**
     * Create setup intent for the user
     * @return Successful Operation
     */
    createSetupIntent(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<CreateSetupIntentResponse>;
    /**
     * Get cards for a user
     * @return Successful Operation
     */
    getCards(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<Card[]>;
    /**
     * Add card to the user
     * @param body The requested field for adding a card
     * @return Successful Operation
     */
    addCard(body: AddCardRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    /**
     * get card using id
     * @param id identification number of the card
     * @return Successful Operation
     */
    getCard(id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<Card>;
    /**
     * get card using id
     * @param id identification number of the card
     * @return Successful Operation
     */
    deleteCard(id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    /**
     * get default card
     * @return Successful Operation
     */
    getDefaultCard(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<Card>;
    /**
     * update default card
     * @param body The requested field for updating the default card
     * @return Successful Operation
     */
    updateDefaultCard(body: UpdateDefaultCardRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    /**
     * upgrade or downgrade the subscription
     * @param id identification number of the subscription
     * @param body The requested field for updating the subscription
     * @return Successful Operation
     */
    updateSubscription(id: string, body: UpdateSubscriptionRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<UpdateSubscriptionResponse>;
    /**
     * Get the current active subscription of user for the given business
     * @return Successful Operation
     */
    getCurrentSubscription(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<CurrentSubscription>;
    /**
     * cancel the current subscription of user
     * @param id id of the subscription to be cancelled
     * @return Successful Operation
     */
    cancelSubscription(id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<CurrentSubscription>;
    /**
     * checks if subscription can be updated
     * @param id id of the subscription to be cancelled
     * @param body The requested field for updating the subscription
     * @return Successful Operation
     */
    checkSubscriptionUpdate(id: string, body: UpdateSubscriptionRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<CheckSubscriptionUpdate>;
    /**
     * Get the referral code for the given user
     * @return Successful Operation
     */
    getReferralCode(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<GetReferralResponse>;
    /**
     * Claim the referral code
     * @param body The request body for claiming the referral bonus
     * @return Successfully claimed the referral bonus
     */
    confirmReferralCode(body: ClaimReferralRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    /**
     * List buckets
     * @param type (optional)
     * @param public_access (optional)
     * @return Successful Operation,
     */
    listBuckets(type?: BucketType[] | undefined, public_access?: BucketPublicType[] | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<Bucket[]>;
    /**
     * Create bucket
     * @param body information to update pin
     * @return Successful Operation
     */
    createBucket(body: CreateBucketRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<Bucket>;
    /**
     * Get a summary of the users buckets
     * @return Successful Operation,
     */
    bucketsSummary(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<BucketSummaryResponse>;
    /**
     * Get bucket by ID
     * @return Successful Operation,
     */
    getBucket(bucket_id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<Bucket>;
    /**
     * Update bucket
     * @param body Updated Bucket details
     * @return Successful Operation
     */
    updateBucket(bucket_id: string, body: UpdateBucketRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    /**
     * remove bucket that's shared with the user
     * @return Successful Operation,
     */
    removeBucket(bucket_id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    /**
     * Info
     * @return Successful Operation
     */
    getBucketInfo(bucket_id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<BucketPersistentResponse>;
    /**
     * Bucket users
     * @return Successful Operation
     */
    getBucketUsers(bucket_id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<BucketUsersResponse>;
    /**
     * Check Upload
     * @param body files details containing paths
     * @return Successful Operation
     */
    checkUploadBucketObjects(bucket_id: string, body: FilesPreUploadRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<FilesPreUploadResponse>;
    /**
     * Upload
     * @param file (optional)
     * @param path (optional)
     * @param deal_duration (optional)
     * @param replication (optional)
     * @return Successful Operation
     */
    uploadBucketObjects(bucket_id: string, file?: FileParameter[] | undefined, path?: string | undefined, deal_duration?: number | null | undefined, replication?: number | null | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<FilesUploadResponse>;
    /**
     * update
     * @param bucket_id bucket identifier
     * @param file (optional)
     * @param path (optional)
     * @param deal_duration (optional)
     * @param replication (optional)
     * @return Successful Operation
     */
    update(bucket_id: string, file?: FileParameter[] | undefined, path?: string | undefined, deal_duration?: number | null | undefined, replication?: number | null | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<FilesUploadResponse>;
    /**
     * Rename/Move File/Folder
     * @param body file path
     * @return Successful Operation
     */
    moveBucketObjects(bucket_id: string, body: FilesMvRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    /**
     * Get File Info
     * @param body file path
     * @return Successful Operation
     */
    getBucketObjectInfo(bucket_id: string, body: FilesPathRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<BucketFileFullInfoResponse>;
    /**
     * Delete File/Folder
     * @param body array of object paths
     * @return Successful Operation
     */
    removeBucketObject(bucket_id: string, body: FilesRmRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    /**
     * List Files
     * @param body file path
     * @return Successful Operation
     */
    getBucketObjectChildrenList(bucket_id: string, body: FilesPathRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<FileContentResponse[]>;
    /**
     * Create Folder
     * @param body directory path
     * @return Successful Operation
     */
    addBucketDirectory(bucket_id: string, body: FilesPathRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<FileContentResponse>;
    /**
     * Share Bucket
     * @param body directory path
     * @return Successful Operation
     */
    shareBucket(bucket_id: string, body: ShareBucketRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    /**
     * Download file from bucket
     * @param body file path
     * @return Successful Operation
     */
    getBucketObjectContent(bucket_id: string, body: FilesPathRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<FileResponse>;
    /**
     * Tree of the File system directories
     * @return Successful Operation
     */
    getBucketDirectoriesTree(bucket_id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<DirectoryContentResponse>;
    /**
     * Get Pin Info
     * @param cid (optional) Return pin objects responsible for pinning the specified CID(s); be aware that using longer hash functions introduces further constraints on the number of CIDs that will fit under the limit of 2000 characters per URL  in browser contexts
     * @param name (optional) Return pin objects with specified name (by default a case-sensitive, exact match)
     * @param match (optional) This query parameter is used to define various matching strategy to match the name. If client does not specify the value, it will be consider exact
     * @param status (optional) Return pin objects for pins with the specified status
     * @param after (optional) Return results created (queued) after provided timestamp
     * @param before (optional) Return results created (queued) before provided timestamp
     * @param limit (optional) Max records to return
     * @param meta (optional) Return pin objects that match specified metadata keys passed as a string representation of a JSON object; when implementing a client library, make sure the parameter is URL-encoded to ensure safe transport
     * @param sortOrder (optional) Specifies the sort order of the pins by created at. By default it will be in descending order of created at timestamp. i.e latest first.
     * @return Successful Operation,
     */
    listPins(cid?: string[] | undefined, name?: string | undefined, match?: any | undefined, status?: Status[] | undefined, after?: Date | undefined, before?: Date | undefined, limit?: number | undefined, meta?: any | undefined, sortOrder?: any | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<PinResult>;
    /**
     * Add pin object
     * @return Successful response
     */
    addPin(body: Pin, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<PinStatus>;
    /**
     * Delete Pin
     * @return Successful Operation
     */
    deletePin(requestid: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    /**
     * Replace pin object
     * @return Successful Operation
     */
    editPin(body: Pin, requestid: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    /**
     * Get pin object
     * @return Successful response
     */
    getPin(requestid: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<PinStatus>;
    /**
     * retrieve asks
     * @return Successful Operation
     */
    getAsks(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<AskIndex>;
    /**
     * retrieve deals
     * @param direction filter by deal type
     * @param only (optional) filter by deal status
     * @return Successful Operation
     */
    getDeals(direction: Direction, only?: Only | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<DealRecord>;
    /**
     * retrieve faults
     * @return Successful Operation
     */
    getFaults(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<FaultsIndexSnapshot>;
    /**
     * retrieve miners
     * @return Successful Operation
     */
    getMiners(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<MinerIndexSnapshot>;
    /**
     * retrieve peers
     * @return Successful Operation
     */
    getPeers(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<PeerInfo>;
    /**
     * retrieve top miners by reputation
     * @param limit words go here
     * @return Successful Operation
     */
    getTopMiners(limit: number, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<Anonymous[]>;
    /**
     * create sharing nonce
     * @param body request body attributes to share a file
     * @return Successful Operation
     */
    createNonce(body: CreateNonceRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<NonceResponse>;
    /**
     * Get all the active nonces for the specific user
     * @return Successful Operation
     */
    getAllNonces(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<NonceResponse[]>;
    /**
     * verify the sharing link
     * @param body request body attributes to verify the link
     * @return successfully verified the sharing link
     */
    verifyNonce(body: VerifyRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    /**
     * revoke the sharing nonce
     * @return Successful Operation
     */
    revokeNonce(id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    /**
     * get the validity of the nonce
     * @return Successful Operation
     */
    isNonceValid(id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<IsValidNonce>;
    /**
     * Search Files
     * @param body Search query object
     * @return successful operation
     */
    searchFiles(body: SearchQueryRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<SearchEntry[]>;
    /**
    * Upload NFT Metadata
    * @param body NFT Data to be uploaded
    * @param hash (optional) -> The hash function to use on generating cid that will be returned on response. If invalid or no option provided it will use default hash(sha2-256).
    * @return Successful Operation
    */
    uploadNFT(body: any, hash?: Hash | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<NftUploadResponse>;
}
export declare class FilesApiClient extends AuthorizedApiBase implements IFilesApiClient {
    private instance;
    private baseUrl;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined;
    constructor(configuration: IConfig, baseUrl?: string, instance?: AxiosInstance);
    /**
     * Login
     * @param body Required object for login request
     * @return successful operation
     */
    loginUser(body: Login, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<AccessRefreshTokens>;
    protected processLoginUser(response: AxiosResponse): Promise<AccessRefreshTokens>;
    /**
     * Service Identity Token Generation
     * @param body (optional)
     * @return successful operation
     */
    generateServiceIdentityToken(body?: ServiceIdentityTokenRequest | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<IdentityToken>;
    protected processGenerateServiceIdentityToken(response: AxiosResponse): Promise<IdentityToken>;
    /**
     * User Profile
     * @return successful operation
     */
    getUser(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<User>;
    protected processGetUser(response: AxiosResponse): Promise<User>;
    /**
     * Update User Profile
     * @param body Updated user object
     * @return Successful Operation
     */
    updateUser(body: UserPatch, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<User>;
    protected processUpdateUser(response: AxiosResponse): Promise<User>;
    /**
     * Link Identity Account to User Profile
     * @param body Updated user object with new identity account
     * @return Successful Operation
     */
    linkProfileUser(body: LinkRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<User>;
    protected processLinkProfileUser(response: AxiosResponse): Promise<User>;
    /**
     * Unlink Identity Account from User Profile
     * @param body Updated user object by removing identity account
     * @return Successful Operation
     */
    unlinkProfileUser(body: IdentityProvider, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<User>;
    protected processUnlinkProfileUser(response: AxiosResponse): Promise<User>;
    /**
     * Email Verify
     * @return successful operation
     */
    getEmailVerify(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    protected processGetEmailVerify(response: AxiosResponse): Promise<void>;
    /**
     * New Email Verify Link
     * @param body Updated user object
     * @return Successful Operation
     */
    postNewEmailVerify(body: VerifyEmailToken, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    protected processPostNewEmailVerify(response: AxiosResponse): Promise<void>;
    /**
     * Refresh Token
     * @param body (optional)
     * @return successful operation
     */
    getRefreshToken(body?: RefreshRequest | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<AccessRefreshTokens>;
    protected processGetRefreshToken(response: AxiosResponse): Promise<AccessRefreshTokens>;
    /**
     * Get Identity Web3 Token
     * @param public_address Public Address that will be associated with the user identity
     * @return Successful Operation
     */
    getIdentityWeb3Token(public_address: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<IdentityToken>;
    protected processGetIdentityWeb3Token(response: AxiosResponse): Promise<IdentityToken>;
    /**
     * Verify Web3 Identity
     * @param body (optional)
     * @return Successful Operation
     */
    postIdentityWeb3Token(body?: Web3RequestToken | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<IdentityToken>;
    protected processPostIdentityWeb3Token(response: AxiosResponse): Promise<IdentityToken>;
    /**
     * Get Identity Email token
     * @param body (optional)
     * @return Successfully send email
     */
    getIdentityEmailToken(body?: EmailIdentityRequestToken | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    protected processGetIdentityEmailToken(response: AxiosResponse): Promise<void>;
    /**
     * Verify Email Identity
     * @param body (optional)
     * @return Successful Operation
     */
    postIdentityEmailToken(body?: EmailIdentityVerifyToken | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<IdentityToken>;
    protected processPostIdentityEmailToken(response: AxiosResponse): Promise<IdentityToken>;
    /**
     * Verify tKey Identity
     * @param body (optional)
     * @return Successful Operation
     */
    verifyServiceIdentityToken(body?: ServiceIdentityVerifyRequest | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<AccessRefreshTokens>;
    protected processVerifyServiceIdentityToken(response: AxiosResponse): Promise<AccessRefreshTokens>;
    /**
     * Sets Master password flag
     * @param body (optional)
     * @return Successful Operation
     */
    secure(body?: SecureRequest | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    protected processSecure(response: AxiosResponse): Promise<void>;
    /**
     * Create New Access Key and Secret Pair for the user
     * @param body Create Access Key request body
     * @return Successful Operation
     */
    createAccessKey(body: CreateAccessKeyReq, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<AccessKey>;
    protected processCreateAccessKey(response: AxiosResponse): Promise<AccessKey>;
    /**
     * Get all the access keys for the user
     * @return Successful Operation
     */
    listAccessKeys(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<AccessKey[]>;
    protected processListAccessKeys(response: AxiosResponse): Promise<AccessKey[]>;
    /**
     * Update access key
     * @param id The access key id to be updated
     * @param body (optional)
     * @return Successful Operation
     */
    updateAccessKey(id: string, body?: AccessKeyUpdate | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    protected processUpdateAccessKey(response: AxiosResponse): Promise<void>;
    /**
     * Delete an access key
     * @param id The access key id to be updated
     * @return Successful Operation
     */
    deleteAccessKey(id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    protected processDeleteAccessKey(response: AxiosResponse): Promise<void>;
    /**
     * Look up user's sharing details
     * @param username (optional) username of user
     * @param public_address (optional) public address of user
     * @param identity_public_key (optional) identity public key of user
     * @return User found
     */
    lookupUser(username?: string | undefined, public_address?: string | undefined, identity_public_key?: string | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<LookupUser>;
    protected processLookupUser(response: AxiosResponse): Promise<LookupUser>;
    /**
     * Abuse Users
     * @return successful operation
     */
    abuseUser(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<string[]>;
    protected processAbuseUser(response: AxiosResponse): Promise<string[]>;
    /**
     * Get User Local Store
     * @return successful operation
     */
    getUserLocalStore(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<{
        [key: string]: string;
    }>;
    protected processGetUserLocalStore(response: AxiosResponse): Promise<{
        [key: string]: string;
    }>;
    /**
     * Update User Local Store
     * @param body Updated user local store
     * @return Successful Operation
     */
    updateUserLocalStore(body: {
        [key: string]: string;
    }, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<{
        [key: string]: string;
    }>;
    protected processUpdateUserLocalStore(response: AxiosResponse): Promise<{
        [key: string]: string;
    }>;
    /**
     * Delete User Local Store
     * @return Successful Operation
     */
    deleteUserLocalStore(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<{
        [key: string]: string;
    }>;
    protected processDeleteUserLocalStore(response: AxiosResponse): Promise<{
        [key: string]: string;
    }>;
    /**
     * check the eligibility of the user for billing
     * @return Successful Operation
     */
    getEligibility(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<EligibilitiesResponse>;
    protected processGetEligibility(response: AxiosResponse): Promise<EligibilitiesResponse>;
    /**
     * Get the invoices related to user and subscription
     * @param subscription_id the subscription id for which invoices are to be fetched
     * @param size (optional) the number of invoices to return in the response
     * @param last_id (optional) the last_id parameter sent by the previous response. It will be used in pagination. you can skip it in first request.
     * @return Successful Operation
     */
    getAllInvoices(subscription_id: string, size?: number | undefined, last_id?: string | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<InvoicesResponse>;
    protected processGetAllInvoices(response: AxiosResponse): Promise<InvoicesResponse>;
    /**
     * pay an invoice
     * @param id identification number of the invoice
     * @return Successful Operation
     */
    payInvoice(id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<InvoiceResponse>;
    protected processPayInvoice(response: AxiosResponse): Promise<InvoiceResponse>;
    /**
     * download invoice pdf
     * @param id identification number of the invoice
     * @return Successful Operation
     */
    downloadInvoice(id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<FileResponse>;
    protected processDownloadInvoice(response: AxiosResponse): Promise<FileResponse>;
    /**
     * Get All available products for a product/service
     * @return Successful Operation
     */
    getAllProducts(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<Product[]>;
    protected processGetAllProducts(response: AxiosResponse): Promise<Product[]>;
    /**
     * Get All purchased products for a user
     * @return Successful Operation
     */
    getPurchasedProducts(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<PurchasedProductResponse[]>;
    protected processGetPurchasedProducts(response: AxiosResponse): Promise<PurchasedProductResponse[]>;
    /**
     * Get a pricing product
     * @param id identification number of the product
     * @return Successful Operation
     */
    getPlan(id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<Product>;
    protected processGetPlan(response: AxiosResponse): Promise<Product>;
    /**
     * Create setup intent for the user
     * @return Successful Operation
     */
    createSetupIntent(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<CreateSetupIntentResponse>;
    protected processCreateSetupIntent(response: AxiosResponse): Promise<CreateSetupIntentResponse>;
    /**
     * Get cards for a user
     * @return Successful Operation
     */
    getCards(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<Card[]>;
    protected processGetCards(response: AxiosResponse): Promise<Card[]>;
    /**
     * Add card to the user
     * @param body The requested field for adding a card
     * @return Successful Operation
     */
    addCard(body: AddCardRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    protected processAddCard(response: AxiosResponse): Promise<void>;
    /**
     * get card using id
     * @param id identification number of the card
     * @return Successful Operation
     */
    getCard(id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<Card>;
    protected processGetCard(response: AxiosResponse): Promise<Card>;
    /**
     * get card using id
     * @param id identification number of the card
     * @return Successful Operation
     */
    deleteCard(id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    protected processDeleteCard(response: AxiosResponse): Promise<void>;
    /**
     * get default card
     * @return Successful Operation
     */
    getDefaultCard(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<Card>;
    protected processGetDefaultCard(response: AxiosResponse): Promise<Card>;
    /**
     * update default card
     * @param body The requested field for updating the default card
     * @return Successful Operation
     */
    updateDefaultCard(body: UpdateDefaultCardRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    protected processUpdateDefaultCard(response: AxiosResponse): Promise<void>;
    /**
     * upgrade or downgrade the subscription
     * @param id identification number of the subscription
     * @param body The requested field for updating the subscription
     * @return Successful Operation
     */
    updateSubscription(id: string, body: UpdateSubscriptionRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<UpdateSubscriptionResponse>;
    protected processUpdateSubscription(response: AxiosResponse): Promise<UpdateSubscriptionResponse>;
    /**
     * Get the current active subscription of user for the given business
     * @return Successful Operation
     */
    getCurrentSubscription(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<CurrentSubscription>;
    protected processGetCurrentSubscription(response: AxiosResponse): Promise<CurrentSubscription>;
    /**
     * cancel the current subscription of user
     * @param id id of the subscription to be cancelled
     * @return Successful Operation
     */
    cancelSubscription(id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<CurrentSubscription>;
    protected processCancelSubscription(response: AxiosResponse): Promise<CurrentSubscription>;
    /**
     * checks if subscription can be updated
     * @param id id of the subscription to be cancelled
     * @param body The requested field for updating the subscription
     * @return Successful Operation
     */
    checkSubscriptionUpdate(id: string, body: UpdateSubscriptionRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<CheckSubscriptionUpdate>;
    protected processCheckSubscriptionUpdate(response: AxiosResponse): Promise<CheckSubscriptionUpdate>;
    /**
     * Get the referral code for the given user
     * @return Successful Operation
     */
    getReferralCode(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<GetReferralResponse>;
    protected processGetReferralCode(response: AxiosResponse): Promise<GetReferralResponse>;
    /**
     * Claim the referral code
     * @param body The request body for claiming the referral bonus
     * @return Successfully claimed the referral bonus
     */
    confirmReferralCode(body: ClaimReferralRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    protected processConfirmReferralCode(response: AxiosResponse): Promise<void>;
    /**
     * List buckets
     * @param type (optional)
     * @param public_access (optional)
     * @return Successful Operation,
     */
    listBuckets(type?: BucketType[] | undefined, public_access?: BucketPublicType[] | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<Bucket[]>;
    protected processListBuckets(response: AxiosResponse): Promise<Bucket[]>;
    /**
     * Create bucket
     * @param body information to update pin
     * @return Successful Operation
     */
    createBucket(body: CreateBucketRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<Bucket>;
    protected processCreateBucket(response: AxiosResponse): Promise<Bucket>;
    /**
     * Get a summary of the users buckets
     * @return Successful Operation,
     */
    bucketsSummary(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<BucketSummaryResponse>;
    protected processBucketsSummary(response: AxiosResponse): Promise<BucketSummaryResponse>;
    /**
     * Get bucket by ID
     * @return Successful Operation,
     */
    getBucket(bucket_id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<Bucket>;
    protected processGetBucket(response: AxiosResponse): Promise<Bucket>;
    /**
     * Update bucket
     * @param body Updated Bucket details
     * @return Successful Operation
     */
    updateBucket(bucket_id: string, body: UpdateBucketRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    protected processUpdateBucket(response: AxiosResponse): Promise<void>;
    /**
     * remove bucket that's shared with the user
     * @return Successful Operation,
     */
    removeBucket(bucket_id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    protected processRemoveBucket(response: AxiosResponse): Promise<void>;
    /**
     * Info
     * @return Successful Operation
     */
    getBucketInfo(bucket_id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<BucketPersistentResponse>;
    protected processGetBucketInfo(response: AxiosResponse): Promise<BucketPersistentResponse>;
    /**
     * Bucket users
     * @return Successful Operation
     */
    getBucketUsers(bucket_id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<BucketUsersResponse>;
    protected processGetBucketUsers(response: AxiosResponse): Promise<BucketUsersResponse>;
    /**
     * Check Upload
     * @param body files details containing paths
     * @return Successful Operation
     */
    checkUploadBucketObjects(bucket_id: string, body: FilesPreUploadRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<FilesPreUploadResponse>;
    protected processCheckUploadBucketObjects(response: AxiosResponse): Promise<FilesPreUploadResponse>;
    /**
     * Upload
     * @param file (optional)
     * @param path (optional)
     * @param deal_duration (optional)
     * @param replication (optional)
     * @return Successful Operation
     */
    uploadBucketObjects(bucket_id: string, file?: FileParameter[] | undefined, path?: string | undefined, deal_duration?: number | null | undefined, replication?: number | null | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<FilesUploadResponse>;
    protected processUploadBucketObjects(response: AxiosResponse): Promise<FilesUploadResponse>;
    /**
     * update
     * @param bucket_id bucket identifier
     * @param file (optional)
     * @param path (optional)
     * @param deal_duration (optional)
     * @param replication (optional)
     * @return Successful Operation
     */
    update(bucket_id: string, file?: FileParameter[] | undefined, path?: string | undefined, deal_duration?: number | null | undefined, replication?: number | null | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<FilesUploadResponse>;
    protected processUpdate(response: AxiosResponse): Promise<FilesUploadResponse>;
    /**
     * Rename/Move File/Folder
     * @param body file path
     * @return Successful Operation
     */
    moveBucketObjects(bucket_id: string, body: FilesMvRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    protected processMoveBucketObjects(response: AxiosResponse): Promise<void>;
    /**
     * Get File Info
     * @param body file path
     * @return Successful Operation
     */
    getBucketObjectInfo(bucket_id: string, body: FilesPathRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<BucketFileFullInfoResponse>;
    protected processGetBucketObjectInfo(response: AxiosResponse): Promise<BucketFileFullInfoResponse>;
    /**
     * Delete File/Folder
     * @param body array of object paths
     * @return Successful Operation
     */
    removeBucketObject(bucket_id: string, body: FilesRmRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    protected processRemoveBucketObject(response: AxiosResponse): Promise<void>;
    /**
     * List Files
     * @param body file path
     * @return Successful Operation
     */
    getBucketObjectChildrenList(bucket_id: string, body: FilesPathRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<FileContentResponse[]>;
    protected processGetBucketObjectChildrenList(response: AxiosResponse): Promise<FileContentResponse[]>;
    /**
     * Create Folder
     * @param body directory path
     * @return Successful Operation
     */
    addBucketDirectory(bucket_id: string, body: FilesPathRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<FileContentResponse>;
    protected processAddBucketDirectory(response: AxiosResponse): Promise<FileContentResponse>;
    /**
     * Share Bucket
     * @param body directory path
     * @return Successful Operation
     */
    shareBucket(bucket_id: string, body: ShareBucketRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    protected processShareBucket(response: AxiosResponse): Promise<void>;
    /**
     * Download file from bucket
     * @param body file path
     * @return Successful Operation
     */
    getBucketObjectContent(bucket_id: string, body: FilesPathRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<FileResponse>;
    protected processGetBucketObjectContent(response: AxiosResponse): Promise<FileResponse>;
    /**
     * Tree of the File system directories
     * @return Successful Operation
     */
    getBucketDirectoriesTree(bucket_id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<DirectoryContentResponse>;
    protected processGetBucketDirectoriesTree(response: AxiosResponse): Promise<DirectoryContentResponse>;
    /**
     * Get Pin Info
     * @param cid (optional) Return pin objects responsible for pinning the specified CID(s); be aware that using longer hash functions introduces further constraints on the number of CIDs that will fit under the limit of 2000 characters per URL  in browser contexts
     * @param name (optional) Return pin objects with specified name (by default a case-sensitive, exact match)
     * @param match (optional) This query parameter is used to define various matching strategy to match the name. If client does not specify the value, it will be consider exact
     * @param status (optional) Return pin objects for pins with the specified status
     * @param after (optional) Return results created (queued) after provided timestamp
     * @param before (optional) Return results created (queued) before provided timestamp
     * @param limit (optional) Max records to return
     * @param meta (optional) Return pin objects that match specified metadata keys passed as a string representation of a JSON object; when implementing a client library, make sure the parameter is URL-encoded to ensure safe transport
     * @param sortOrder (optional) Specifies the sort order of the pins by created at. By default it will be in descending order of created at timestamp. i.e latest first.
     * @return Successful Operation,
     */
    listPins(cid?: string[] | undefined, name?: string | undefined, match?: any | undefined, status?: Status[] | undefined, after?: Date | undefined, before?: Date | undefined, limit?: number | undefined, meta?: any | undefined, sortOrder?: any | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<PinResult>;
    protected processListPins(response: AxiosResponse): Promise<PinResult>;
    /**
     * Add pin object
     * @return Successful response
     */
    addPin(body: Pin, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<PinStatus>;
    protected processAddPin(response: AxiosResponse): Promise<PinStatus>;
    /**
     * Delete Pin
     * @return Successful Operation
     */
    deletePin(requestid: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    protected processDeletePin(response: AxiosResponse): Promise<void>;
    /**
     * Replace pin object
     * @return Successful Operation
     */
    editPin(body: Pin, requestid: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    protected processEditPin(response: AxiosResponse): Promise<void>;
    /**
     * Get pin object
     * @return Successful response
     */
    getPin(requestid: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<PinStatus>;
    protected processGetPin(response: AxiosResponse): Promise<PinStatus>;
    /**
     * retrieve asks
     * @return Successful Operation
     */
    getAsks(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<AskIndex>;
    protected processGetAsks(response: AxiosResponse): Promise<AskIndex>;
    /**
     * retrieve deals
     * @param direction filter by deal type
     * @param only (optional) filter by deal status
     * @return Successful Operation
     */
    getDeals(direction: Direction, only?: Only | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<DealRecord>;
    protected processGetDeals(response: AxiosResponse): Promise<DealRecord>;
    /**
     * retrieve faults
     * @return Successful Operation
     */
    getFaults(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<FaultsIndexSnapshot>;
    protected processGetFaults(response: AxiosResponse): Promise<FaultsIndexSnapshot>;
    /**
     * retrieve miners
     * @return Successful Operation
     */
    getMiners(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<MinerIndexSnapshot>;
    protected processGetMiners(response: AxiosResponse): Promise<MinerIndexSnapshot>;
    /**
     * retrieve peers
     * @return Successful Operation
     */
    getPeers(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<PeerInfo>;
    protected processGetPeers(response: AxiosResponse): Promise<PeerInfo>;
    /**
     * retrieve top miners by reputation
     * @param limit words go here
     * @return Successful Operation
     */
    getTopMiners(limit: number, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<Anonymous[]>;
    protected processGetTopMiners(response: AxiosResponse): Promise<Anonymous[]>;
    /**
     * create sharing nonce
     * @param body request body attributes to share a file
     * @return Successful Operation
     */
    createNonce(body: CreateNonceRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<NonceResponse>;
    protected processCreateNonce(response: AxiosResponse): Promise<NonceResponse>;
    /**
     * Get all the active nonces for the specific user
     * @return Successful Operation
     */
    getAllNonces(cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<NonceResponse[]>;
    protected processGetAllNonces(response: AxiosResponse): Promise<NonceResponse[]>;
    /**
     * verify the sharing link
     * @param body request body attributes to verify the link
     * @return successfully verified the sharing link
     */
    verifyNonce(body: VerifyRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    protected processVerifyNonce(response: AxiosResponse): Promise<void>;
    /**
     * revoke the sharing nonce
     * @return Successful Operation
     */
    revokeNonce(id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<void>;
    protected processRevokeNonce(response: AxiosResponse): Promise<void>;
    /**
     * get the validity of the nonce
     * @return Successful Operation
     */
    isNonceValid(id: string, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<IsValidNonce>;
    protected processIsNonceValid(response: AxiosResponse): Promise<IsValidNonce>;
    /**
     * Search Files
     * @param body Search query object
     * @return successful operation
     */
    searchFiles(body: SearchQueryRequest, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<SearchEntry[]>;
    protected processSearchFiles(response: AxiosResponse): Promise<SearchEntry[]>;
    /**
     * Upload NFT Metadata
     * @param body NFT Data to be uploaded
     * @param hash (optional) -> The hash function to use on generating cid that will be returned on response. If invalid or no option provided it will use default hash(sha2-256).
     * @return Successful Operation
     */
    uploadNFT(body: any, hash?: Hash | undefined, cancelToken?: CancelToken | undefined, onDownloadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void, onUploadProgress?: (progressEvent: ProgressEvent<EventTarget>) => void): Promise<NftUploadResponse>;
    protected processUploadNFT(response: AxiosResponse): Promise<NftUploadResponse>;
}
export interface Login {
    /** Identity token */
    token: string;
    /** Name of provider of login process. */
    provider: LoginProvider;
    /** Name of the service for which returned auth token will be valid */
    service: LoginService;
}
export interface ErrorMessage {
    /** The error object */
    error?: ErrorDto;
}
export interface Token {
    /** Authentication token used for api access */
    token: string;
    /** The Expiration date of the token */
    expires: string;
}
export interface AccessRefreshTokens {
    access_token: Token;
    refresh_token: Token;
}
/** Provider of identity token */
export declare type IdentityProvider = "web3" | "google" | "github" | "email";
export interface ServiceIdentityTokenRequest {
    identity_provider: IdentityProvider;
    identity_token: string;
}
export interface IdentityToken {
    /** Either JWT Token for thew Web3/OAuth login or Welcome Phrase to show to user */
    token: string;
    expires: string;
}
export interface User {
    /** Identification Number of the User */
    id: number;
    /** Timestamp of the User creation event */
    created_at: Date;
    /** Timestamp of the last User last update */
    updated_at?: Date;
    /** Timestamp of the Users Delete event */
    deleted_at?: Date;
    /** The Universal Unique Identifier of the User */
    uuid: string;
    /** First Name of tne User */
    first_name?: string;
    /** Last Name of the User */
    last_name?: string;
    /** UserName of the User */
    username?: string;
    /** Public Address of the User */
    public_address?: string;
    /** Email Address of the User */
    email?: string;
    /** Phone number of the User */
    phone?: string;
    /** Is the User Active */
    active: boolean;
    /** Is the User Verified */
    verified: boolean;
    /** Is the User Payments Activated */
    payment_active?: boolean;
    /** Timestamp of the Users last login */
    last_login?: string;
    /** Timpstamp of the User's last password change */
    last_password_change?: string;
    /** Timestamp of the User's last email change */
    last_email_change?: string;
    /** IP address of the User's last login */
    login_ip?: string;
    /** Timestamp of the last User login */
    login_at?: string;
    /** Browser used by the User last */
    browser?: string;
    /** City the User has registered */
    city?: string;
    /** Country the User has registered */
    country?: string;
    identity_providers?: IdentityProvider[];
    /** user discoverable flag */
    user_lookup_consent?: boolean;
}
export interface UserPatch {
    /** First Name of the User */
    first_name: string;
    /** Last Name of the User */
    last_name: string;
    /** Email Address of the User */
    email: string;
    /** UserName of the User */
    username?: string;
    /** Phone Number of the User */
    phone?: string;
    /** City of the User */
    city?: string;
    /** Country of the User */
    country?: string;
    /** user discoverable flag */
    lookup_consent_flag?: boolean;
}
export interface LinkRequest {
    /** Token gotten from calling the web3/<pub_key> API or OAuth */
    identity_token: string;
    identity_provider: IdentityProvider;
}
export interface VerifyEmailToken {
    /** Identification Number of the User */
    id: number;
    /** Authenticaton Token */
    token: string;
}
/** Body of a refresh token endpoint */
export interface RefreshRequest {
    /** Refresh token used for access token generation */
    refresh: string;
}
export interface Web3RequestToken {
    /** Public Address of the user */
    public_address?: string;
    /** Token gotten from calling the web3 login API or an empty string in case of Web3 Identity Verification */
    token: string;
    /** Signature of the Token generated using user's Private Key */
    signature: string;
}
export interface EmailIdentityRequestToken {
    /** email address of the user */
    email: string;
}
export interface EmailIdentityVerifyToken {
    /** Email Address of the user */
    email: string;
    /** Nonce gotten from calling email idenity login api */
    nonce: string;
}
export interface ServiceIdentityVerifyRequest {
    /** Public Key that will be used to encrypt user symmetric key. `0x` prefixed HEX string */
    public_key: string;
    /** Signature of the Token generated using user's Private Key */
    signature: string;
    /** Token gotten from calling the `user/identity` API */
    service_identity_token: string;
}
/** Either one of those propperties needs to be provided. If porvided both `mps` will be ignored */
export interface SecureRequest {
    /** User's symmetric encryption phrase encrypted with user's tKey public key */
    encryption_key?: string;
    /** User's Master Password Sample. Which is known string encoded with user password. Used by UI to have password verification capability */
    mps?: string;
}
/** type of access key */
export declare type AccessKeyType = "gaming" | "storage" | "s3";
export interface AccessKey {
    /** access key id */
    id: string;
    /** access key secret */
    secret: string;
    /** current status for access key. Possible values: active or inactive */
    status: AccessKeyStatus;
    /** Creation time of the access key */
    created_at: string;
    type: AccessKeyType;
    /** owner unique identidier */
    user_uuid: string;
}
export interface CreateAccessKeyReq {
    type: AccessKeyType;
}
export interface AccessKeyUpdate {
    /** current status for access key. Possible values can be active or inactive */
    status: AccessKeyUpdateStatus;
}
export interface LookupUser {
    /** User DB ID */
    id: string;
    /** Unique user Identifier */
    uuid: string;
    /** Unique user name for */
    username: string;
    /** A 68 digit long Tkey public address */
    identity_pubkey: string;
    /** A 42 digit long web3 public address */
    public_address: string;
}
/** Local store generic object */
export interface LocalStore {
    [key: string]: string | any;
}
export interface EligibilitiesResponse {
    /** denotes if user is eligible for billing */
    is_eligible: boolean;
}
/** recurring component of the price describes how user will be charged */
export interface ProductPriceRecurring {
    /** describes how the quantity per period should be determined */
    usage_type: ProductPriceRecurringUsage_type;
    /** frequency at which a subscription is billed */
    interval: ProductPriceRecurringInterval;
    /** number of intervals */
    interval_count: number;
}
/** information about the price of a product. A product can have multiple pricing models like $20/month, $50/3-month, $180/year */
export interface ProductPrice {
    /** Price id */
    id: string;
    /** Three-letter ISO currency code */
    currency: string;
    /** type of the price */
    type: ProductPriceType;
    /** amount per unit */
    unit_amount: number;
    /** tax type of the pricing */
    tax_behavior: ProductPriceTax_behavior;
    recurring: ProductPriceRecurring;
    is_update_allowed: boolean;
    metadata?: {
        [key: string]: string;
    };
}
/** info about Plan */
export interface SubscribedProduct {
    /** Product id */
    id: string;
    /** Name of the product */
    name: string;
    /** Description of the product */
    description: string;
    /** Price of the Subscribed product */
    price: ProductPrice;
}
/** Info about a crypto payment method */
export interface CryptoPaymentOption {
    currency: string;
    address: string;
    amount: string;
}
/** object that represents the invoice response */
export interface InvoiceResponse {
    /** uuid of the invoice */
    uuid: string;
    /** user id to which the invoice belongs to */
    user_id: string;
    /** subscription id of subscription to which the invoice belongs to */
    subscription_id: string;
    /** product details */
    product: SubscribedProduct;
    /** invoice amount */
    amount: number;
    /** currency of money paid for the invoice */
    currency: string;
    /** the payment method used for the invoice to pay the amount */
    payment_method: InvoiceResponsePayment_method;
    /** current status of the invoice */
    status: InvoiceResponseStatus;
    /** date time invoice on */
    paid_on: number;
    /** invoice current period start date */
    period_start: number;
    /** invoice current period end date */
    period_end: number;
    crypto?: Crypto;
}
export interface InvoicesResponse {
    /** Its the last id of the invoice of the response. */
    last_id: string;
    /** The number of invoices that client requested in the request. by default its 10 */
    page_size: number;
    /** The list of invoices */
    invoices: InvoiceResponse[];
}
/** info about Plan */
export interface Product {
    /** Plan id */
    id: string;
    /** Name of the product */
    name: string;
    /** Description of the product */
    description: string;
    /** Array of the various pricing options available for this product */
    prices: ProductPrice[];
}
export interface PurchasedProductResponse {
    /** Product id for which the purchase is done */
    product_id: string;
    /** Name of the product for the product belongs to */
    product_name: string;
    /** The Quantity this product belongs to */
    quantity: number;
    /** Total prize for the above quantity in cents(USD). */
    prize?: number;
    /** The date till when the product is valid */
    expires: string;
}
export interface CreateSetupIntentResponse {
    /** setup intent secret */
    secret: string;
}
export interface Card {
    /** id of the card */
    id: string;
    /** brand of the card */
    brand: CardBrand;
    /** type of card */
    type: CardType;
    /** card month expiry */
    exp_month: number;
    /** card year expiry */
    exp_year: number;
    /** last four digit of the card number */
    last_four_digit: string;
}
export interface AddCardRequest {
    /** token returned from adding a card using stripe Tokenization */
    token: string;
}
export interface UpdateDefaultCardRequest {
    /** id of the card */
    id: string;
}
export interface UpdateSubscriptionRequest {
    /** new price id for subscription upgrade/downgrade */
    price_id: string;
    /** payment method to be used for the updated subscription */
    payment_method: UpdateSubscriptionRequestPayment_method;
}
export interface CurrentSubscription {
    /** Subscription id for which the purchase is done */
    id: string;
    /** Status of the subscription */
    status: CurrentSubscriptionStatus;
    /** The start date of the current period of subscription */
    start_date: number;
    /** The end date of the current period of subscription */
    expiry_date: number;
    product: SubscribedProduct;
}
export interface UpdateSubscriptionResponse {
    subscription: CurrentSubscription;
    invoice?: InvoiceResponse;
}
export interface CheckSubscriptionUpdate {
    /** Amount of the new plan. */
    plan_amount: number;
    /** Amount required to pay. */
    amount_due: number;
    /** Amount left from last subcription. */
    amount_unused_from_last_bill: number;
    /** Amount deducted from user credit. Currently only supported for card payment. */
    amount_from_credit: number;
    /** Amount that will be added to used credit. */
    amount_credited: number;
}
/** client response body for get referral code request */
export interface GetReferralResponse {
    /** referral code hash of the user */
    referral_code: string;
}
export interface ClaimReferralRequest {
    /** referral code hash to be claimed bonus for */
    referral_code: string;
}
/** the type of the bucket (csf value for now automatically set based on the URL path) */
export declare type BucketType = "csf" | "fps" | "trash" | "pinning" | "share" | "nft";
/** this parameter allows to filter buckets by their public access types, if none provided all public the buckets going to be entirely skipped */
export declare type BucketPublicType = "read" | "write";
/** object that represents bucket user entry */
export interface BucketUser {
    /** unique user identifier */
    uuid: string;
    /** data encryption key for the user */
    encryption_key: string;
}
/** Filesystem used for the bucket(chainsafe/ipfs) */
export declare type FileSystemType = "chainsafe" | "ipfs";
export interface Bucket {
    /** bucket identifier */
    id: string;
    /** bucket name that later can be used as DNS name, if bucket has no name that field won't be returned */
    name?: string;
    type: BucketType;
    /** list of user identifiers that owns this bucket */
    owners: BucketUser[];
    /** list of user identifiers that has write permission to the bucket */
    writers: BucketUser[];
    /** list of user identifiers that has read permission to the bucket */
    readers: BucketUser[];
    /** the size of all uploaded entities (files, cids, etc ...) */
    size: number;
    public?: BucketPublicType;
    file_system_type: FileSystemType | undefined;
    /** status of the bucket */
    status: BucketStatus;
}
export interface CreateBucketRequest {
    /** bucket name that later can be used as DNS name */
    name: string;
    type: BucketType;
    /** User's symmetric encryption phrase encrypted with user's tKey public key */
    encryption_key: string;
    file_system_type?: FileSystemType | undefined;
    /** list of id of users */
    writers?: BucketUser[];
    /** list of id of users */
    readers?: BucketUser[];
    public?: BucketPublicType;
}
/** a summary of the users buckets */
export interface BucketSummaryResponse {
    /** Total number for buckets */
    total_buckets: number;
    /** Total available storage */
    available_storage: number;
    /** Total storage for all services */
    total_storage: number;
    /** Total used storage */
    used_storage: any;
}
export interface UpdateBucketRequest {
    /** bucket name */
    name?: string;
    /** list of id of users */
    writers?: BucketUser[];
    /** list of id of users */
    readers?: BucketUser[];
    public?: BucketPublicType;
}
/** information about storage options for the Files object in question */
export interface BucketPersistentResponse {
    /** time what file was uploaded */
    uploaded?: number;
    /** time what file land on storage layer after all deals */
    saved_time?: number;
    /** size of stored file in bytes */
    stored_size?: number;
    /** cid of the sored file in ipfs, usaully the same as cid in content section */
    stored_cid?: string;
    /** File Coin storage details */
    filecoin?: Filecoin;
}
export interface BucketUsersResponse {
    /** user meta for owners */
    owners: LookupUser[];
    /** user meta for writers */
    writers: LookupUser[];
    /** user meta for readers */
    readers: LookupUser[];
}
export interface PreUploadRequestItem {
    /** full path of the file to be uploaded */
    path: string;
}
export interface FilesPreUploadRequest {
    /** if true it will update the existing files */
    is_update: boolean;
    /** Array of full file paths to be uploaded, to be checked for file-system conflicts */
    files_meta: PreUploadRequestItem[];
}
export interface PreUploadResponseDetail {
    /** path of the uploading file */
    path: string;
    /** status of the uploading file */
    status: PreUploadResponseDetailStatus;
    /** http error code for the file */
    error_code?: number;
    /** error message in case of status failed */
    message?: string;
    /** suggested path for conflict error */
    suggestion?: string;
}
export interface FilesPreUploadResponse {
    /** status of the upload */
    status: FilesPreUploadResponseStatus;
    /** array of files */
    files_details: PreUploadResponseDetail[];
}
export interface FilesUploadResponse {
    /** path where all uploaded files are placed */
    path: string;
}
export interface FilesMvRequest {
    /** path to the file object (to be deprecated) */
    path?: string;
    /** list of paths to be moved */
    paths: string[];
    /** desired new path file object needs to be moved */
    new_path: string;
    destination?: string;
}
export interface FilesPathRequest {
    /** path to the file object */
    path: string;
    source?: string;
}
/** service specific Files object info */
export interface FileContentResponse {
    /** File or Flder object name */
    name: string;
    /** File or Folder content identifier */
    cid: string;
    /** size of the file */
    size: number;
    /** Content type */
    content_type: string;
    /** File storage type version; only files version has some meaning, all folder always have version 0 */
    version: number;
    /** creation date */
    created_at: number;
}
export interface BucketFileFullInfoResponse {
    content?: FileContentResponse;
    persistent?: BucketPersistentResponse;
    /** list of messages containig warnings and errors about File Coin deals that filed */
    messages?: string[];
}
export interface FilesRmRequest {
    /** list of paths to the file objects that needs to be deleted */
    paths: string[];
    source?: string;
}
/** share bucket request body object */
export interface ShareBucketRequest {
    /** path of file/fold shared */
    path: string;
    /** shared bucket uuid */
    bucket_id: string;
}
/** service specific Directory object info */
export interface DirectoryContentResponse {
    /** File or Folder object name */
    name: string;
    /** File or Folder content identifier */
    cid: string;
    /** File or Folder path in file system */
    path: string;
    /** size of the file */
    size: number;
    /** content type */
    content_type: string;
    /** list of sub directories */
    entries: DirectoryContentResponse[];
}
/** Status a pin object can have at a pinning service */
export declare type Status = "queued" | "pinning" | "pinned" | "failed";
/** Optional metadata for pin object */
export interface PinMeta {
    [key: string]: string | any;
}
/** Response for a failed request */
export interface PinningError {
    error?: Error;
}
/** Pin object */
export interface Pin {
    /** Content Identifier (CID) to be pinned recursively */
    cid: string;
    /** Optional name for pinned data; can be used for lookups later */
    name?: string;
    origins?: string[];
    meta?: PinMeta;
}
/** Optional info for PinStatus response */
export interface StatusInfo {
    [key: string]: string | any;
}
/** Pin object with status */
export interface PinStatus {
    /** Globally unique identifier of the pin request; can be used to check the status of ongoing pinning, or pin removal */
    requestid: string;
    status: Status;
    /** Immutable timestamp indicating when a pin request entered a pinning service; can be used for filtering results and pagination */
    created: Date;
    pin: Pin;
    delegates: string[];
    info?: StatusInfo;
}
/** Response used for listing pin objects matching request */
export interface PinResult {
    /** The total number of remaining pin objects that exist for passed query filters. if the count is more than the length of the results, there are more results available. */
    count?: number;
    /** An array of PinStatus results. The results are by default ordered in decending order of created at timestamp. */
    results?: PinStatus[];
}
export interface AskIndex {
    /** date last updated_at */
    lastupdated?: string;
    /** storage median price */
    storagemedianprice?: number;
    /** information about the storage ask */
    storage?: any;
}
/** record for current deal */
export interface DealRecord {
}
/** index snapshot with map of miners and faults */
export interface FaultsIndexSnapshot {
}
/** index snapshot miners info */
export interface MinerIndexSnapshot {
}
/** info about peers including network and location data */
export interface PeerInfo {
}
export interface NonceResponse {
    /** id of the nonce created */
    id: string;
    /** permissions allowed for the nonce */
    permission: NonceResponsePermission;
    /** does sharing link nonce have unlimited validity */
    unlimited_validity: boolean;
    /** The user which created the nonce */
    user_id?: string;
    /** The bucket for which the nonce is created for. */
    bucket_id?: string;
}
export interface CreateNonceRequest {
    /** bucket id of the bucket to share */
    bucket_id: string;
    /** permission to be granted to other users */
    permission: CreateNonceRequestPermission;
}
export interface VerifyRequest {
    /** JWT token created for the sharing link */
    jwt: string;
    /** encrypted encryption key from the user who clicks on the link */
    encryption_key: string;
}
export interface IsValidNonce {
    /** whether the given nonce is still valid or not */
    is_valid: boolean;
}
export interface SearchQueryRequest {
    /** user provided search query */
    query: string;
    /** bucket id */
    bucket_id: string;
}
export interface SearchEntry {
    /** file path */
    path: string;
    /** bucket id */
    bucket_id?: string;
    /** user ids */
    user_ids: number[];
    /** is file starred */
    is_starred?: boolean;
    content: FileContentResponse;
}
export interface NftUploadResponse {
    /** CID of the uploaded content */
    cid: string;
}
export declare type Direction = "retrieval" | "storage";
export declare type Only = "final" | "pending";
export declare type Hash = "identity" | "sha1" | "sha2-256" | "sha2-512" | "sha3" | "sha3-224" | "sha3-256" | "sha3-384" | "sha3-512" | "keccak-224" | "keccak-256" | "keccak-384" | "keccak-512" | "blake2b-n.8 (1<=n<=64)" | "blake2s-n.8 (1<=n<=32)" | "dbl-sha2-256" | "murmur3-x64-64" | "blake3" | "shake-128" | "shake-256" | "sha2-256-trunc254-padded" | "x11" | "md5" | "poseidon-bls12_381-a2-fc1" | "blake2b-208";
export interface Anonymous {
    /** miner address */
    addr?: string;
    /** miner current score */
    score?: number;
}
export declare type LoginProvider = "email" | "web3" | "github" | "google";
export declare type LoginService = "gaming" | "storage";
export interface ErrorDto {
    /** Http error code */
    code?: number;
    /** Error message */
    message?: string;
    /** Holds error details in case of validation errors or multiple errors */
    details?: Details[];
}
export declare type AccessKeyStatus = "active" | "inactive";
export declare type AccessKeyUpdateStatus = "active" | "inactive";
export declare type ProductPriceRecurringUsage_type = "metered" | "licensed";
export declare type ProductPriceRecurringInterval = "day" | "week" | "month" | "year";
export declare type ProductPriceType = "one_time" | "recurring";
export declare type ProductPriceTax_behavior = "inclusive" | "exclusive" | "unspecified";
export declare type InvoiceResponsePayment_method = "stripe" | "crypto";
export declare type InvoiceResponseStatus = "open" | "paid" | "draft" | "void";
export interface Crypto {
    expires_at: number;
    /** list of crypto payment methods */
    payment_methods: CryptoPaymentOption[];
}
export declare type CardBrand = "American Express" | "Diners Club" | "Discover" | "JCB" | "MasterCard" | "UnionPay" | "Visa" | "Unknown";
export declare type CardType = "credit" | "debit" | "prepaid" | "unknown";
export declare type UpdateSubscriptionRequestPayment_method = "crypto" | "stripe";
export declare type CurrentSubscriptionStatus = "active" | "past_due" | "pending_update";
export declare type BucketStatus = "created" | "deleting";
export interface Filecoin {
    /** cid of the sotred onject in File Coin network */
    cid?: string;
    /** size of sored data in File Coin network, usually quanted by minimum stored size */
    size?: number;
    /** info about File Coin proposals */
    proposals?: Proposals[];
}
export declare type PreUploadResponseDetailStatus = "success" | "failed";
export declare type FilesPreUploadResponseStatus = "success" | "failed";
export interface Error {
    /** Mandatory string identifying the type of error */
    reason?: string;
    /** Optional, longer description of the error */
    details?: string;
}
export declare type NonceResponsePermission = "read" | "write";
export declare type CreateNonceRequestPermission = "read" | "write";
export interface Details {
    /** Error type or source */
    type?: string;
    /** Error message */
    message?: string;
}
export interface Proposals {
    /** cid of the proposal data */
    cid?: string;
    /** deal duration in seonds */
    duration?: number;
    /** activation epoch number */
    activation_epoch?: number;
    /** start epoch number */
    start_epoch?: number;
    /** responsible miner */
    miner?: string;
    /** epoch price */
    epoch_price?: number;
}
export interface FileParameter {
    data: any;
    fileName: string;
}
export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: {
        [name: string]: any;
    };
}
export declare class FilesApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: {
        [key: string]: any;
    };
    result: any;
    constructor(message: string, status: number, response: string, headers: {
        [key: string]: any;
    }, result: any);
    protected isFilesApiException: boolean;
    static isFilesApiException(obj: any): obj is FilesApiException;
}
/**
 * Configuration class needed in base class.
 * The config is provided to the API client at initialization time.
 * API clients inherit from #AuthorizedApiBase and provide the config.
 */
export declare class IConfig {
}
//# sourceMappingURL=FilesApiClient.d.ts.map