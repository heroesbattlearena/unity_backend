"use strict";
/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.8.0 (NJsonSchema v10.6.7.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
// @ts-nocheck
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IConfig = exports.FilesApiException = exports.FilesApiClient = exports.AuthorizedApiBase = void 0;
const axios_1 = __importDefault(require("axios"));
const formDataHelper_1 = require("./formDataHelper");
const form_data_encoder_1 = require("@chainsafe/form-data-encoder");
const stream_1 = require("stream");
const browser_or_node_1 = require("browser-or-node");
class AuthorizedApiBase {
    constructor(config, accessToken = "") {
        this.transformOptions = (options) => {
            options.headers = Object.assign(Object.assign({}, options.headers), { Authorization: this.accessToken ? `Bearer ${this.accessToken}` : "" });
            return Promise.resolve(options);
        };
        this.config = config;
        this.accessToken = accessToken;
    }
    setToken(accessToken) {
        this.accessToken = accessToken;
    }
}
exports.AuthorizedApiBase = AuthorizedApiBase;
class FilesApiClient extends AuthorizedApiBase {
    constructor(configuration, baseUrl, instance) {
        super(configuration);
        this.jsonParseReviver = undefined;
        this.instance = instance ? instance : axios_1.default.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://stage.api.chainsafe.site";
    }
    /**
     * Login
     * @param body Required object for login request
     * @return successful operation
     */
    loginUser(body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/user/login";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processLoginUser(_response);
        });
    }
    processLoginUser(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid Request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Invalid identity token", status, _responseText, _headers, result403);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Service Identity Token Generation
     * @param body (optional)
     * @return successful operation
     */
    generateServiceIdentityToken(body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/user/identity";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGenerateServiceIdentityToken(_response);
        });
    }
    processGenerateServiceIdentityToken(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid provider supplied", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Invalid oauth2 code supplied", status, _responseText, _headers, result403);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * User Profile
     * @return successful operation
     */
    getUser(cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/user/profile";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetUser(_response);
        });
    }
    processGetUser(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Update User Profile
     * @param body Updated user object
     * @return Successful Operation
     */
    updateUser(body, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/user/profile";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processUpdateUser(_response);
        });
    }
    processUpdateUser(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("Email Verification sent recently", status, _responseText, _headers, result409);
        }
        else if (status === 412) {
            const _responseText = response.data;
            let result412 = null;
            let resultData412 = _responseText;
            result412 = JSON.parse(resultData412);
            return throwException("User with this email, phone number or username already exists", status, _responseText, _headers, result412);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Link Identity Account to User Profile
     * @param body Updated user object with new identity account
     * @return Successful Operation
     */
    linkProfileUser(body, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/user/profile/link";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processLinkProfileUser(_response);
        });
    }
    processLinkProfileUser(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("This provider already associated with user", status, _responseText, _headers, result409);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Unlink Identity Account from User Profile
     * @param body Updated user object by removing identity account
     * @return Successful Operation
     */
    unlinkProfileUser(body, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/user/profile/link";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processUnlinkProfileUser(_response);
        });
    }
    processUnlinkProfileUser(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("This provider is not associated with user", status, _responseText, _headers, result409);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Email Verify
     * @return successful operation
     */
    getEmailVerify(cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/user/email/confirm";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {},
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetEmailVerify(_response);
        });
    }
    processGetEmailVerify(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Email already verified", status, _responseText, _headers, result403);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("Email sent recently", status, _responseText, _headers, result409);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * New Email Verify Link
     * @param body Updated user object
     * @return Successful Operation
     */
    postNewEmailVerify(body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/user/email/confirm";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processPostNewEmailVerify(_response);
        });
    }
    processPostNewEmailVerify(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Confirmation or reset token is invalid", status, _responseText, _headers, result403);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("Email already verified", status, _responseText, _headers, result409);
        }
        else if (status === 412) {
            const _responseText = response.data;
            let result412 = null;
            let resultData412 = _responseText;
            result412 = JSON.parse(resultData412);
            return throwException("Confirmation or reset token expired", status, _responseText, _headers, result412);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Refresh Token
     * @param body (optional)
     * @return successful operation
     */
    getRefreshToken(body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/user/refresh";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetRefreshToken(_response);
        });
    }
    processGetRefreshToken(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Confirmation or reset token is invalid", status, _responseText, _headers, result403);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Get Identity Web3 Token
     * @param public_address Public Address that will be associated with the user identity
     * @return Successful Operation
     */
    getIdentityWeb3Token(public_address, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/user/web3/{public_address}";
        if (public_address === undefined || public_address === null)
            throw new Error("The parameter 'public_address' must be defined.");
        url_ = url_.replace("{public_address}", encodeURIComponent("" + public_address));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetIdentityWeb3Token(_response);
        });
    }
    processGetIdentityWeb3Token(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Verify Web3 Identity
     * @param body (optional)
     * @return Successful Operation
     */
    postIdentityWeb3Token(body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/user/web3/verify";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processPostIdentityWeb3Token(_response);
        });
    }
    processPostIdentityWeb3Token(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("The provided signature, confirmation or reset token is invalid", status, _responseText, _headers, result403);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Get Identity Email token
     * @param body (optional)
     * @return Successfully send email
     */
    getIdentityEmailToken(body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/user/email";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetIdentityEmailToken(_response);
        });
    }
    processGetIdentityEmailToken(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Verify Email Identity
     * @param body (optional)
     * @return Successful Operation
     */
    postIdentityEmailToken(body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/user/email/verify";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processPostIdentityEmailToken(_response);
        });
    }
    processPostIdentityEmailToken(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("The provided nonce is invalid", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("The provided nonce not found", status, _responseText, _headers, result404);
        }
        else if (status === 412) {
            const _responseText = response.data;
            let result412 = null;
            let resultData412 = _responseText;
            result412 = JSON.parse(resultData412);
            return throwException("The provided nonce is expired", status, _responseText, _headers, result412);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Verify tKey Identity
     * @param body (optional)
     * @return Successful Operation
     */
    verifyServiceIdentityToken(body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/user/identity/verify";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processVerifyServiceIdentityToken(_response);
        });
    }
    processVerifyServiceIdentityToken(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("The provided signature, confirmation or reset token is invalid", status, _responseText, _headers, result403);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Sets Master password flag
     * @param body (optional)
     * @return Successful Operation
     */
    secure(body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/user/secure";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processSecure(_response);
        });
    }
    processSecure(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("User can\'t call this endpoint twice", status, _responseText, _headers, result403);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Create New Access Key and Secret Pair for the user
     * @param body Create Access Key request body
     * @return Successful Operation
     */
    createAccessKey(body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/user/keys";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processCreateAccessKey(_response);
        });
    }
    processCreateAccessKey(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("Maximum limit for creating access key exceeds", status, _responseText, _headers, result409);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Get all the access keys for the user
     * @return Successful Operation
     */
    listAccessKeys(cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/user/keys";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processListAccessKeys(_response);
        });
    }
    processListAccessKeys(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Update access key
     * @param id The access key id to be updated
     * @param body (optional)
     * @return Successful Operation
     */
    updateAccessKey(id, body, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/user/keys/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processUpdateAccessKey(_response);
        });
    }
    processUpdateAccessKey(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Bad Request. Something wrong with user input", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("No access key with this id was found", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Delete an access key
     * @param id The access key id to be updated
     * @return Successful Operation
     */
    deleteAccessKey(id, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/user/keys/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            url: url_,
            headers: {},
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processDeleteAccessKey(_response);
        });
    }
    processDeleteAccessKey(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("No access key with this id was found", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Look up user's sharing details
     * @param username (optional) username of user
     * @param public_address (optional) public address of user
     * @param identity_public_key (optional) identity public key of user
     * @return User found
     */
    lookupUser(username, public_address, identity_public_key, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/user/lookup?";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        if (public_address === null)
            throw new Error("The parameter 'public_address' cannot be null.");
        else if (public_address !== undefined)
            url_ += "public_address=" + encodeURIComponent("" + public_address) + "&";
        if (identity_public_key === null)
            throw new Error("The parameter 'identity_public_key' cannot be null.");
        else if (identity_public_key !== undefined)
            url_ += "identity_public_key=" + encodeURIComponent("" + identity_public_key) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processLookupUser(_response);
        });
    }
    processLookupUser(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("User not found", status, _responseText, _headers, result404);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Error looking up user", status, _responseText, _headers, result500);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Abuse Users
     * @return successful operation
     */
    abuseUser(cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/user/abuse";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processAbuseUser(_response);
        });
    }
    processAbuseUser(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Get User Local Store
     * @return successful operation
     */
    getUserLocalStore(cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/user/store";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetUserLocalStore(_response);
        });
    }
    processGetUserLocalStore(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Update User Local Store
     * @param body Updated user local store
     * @return Successful Operation
     */
    updateUserLocalStore(body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/user/store";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processUpdateUserLocalStore(_response);
        });
    }
    processUpdateUserLocalStore(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Delete User Local Store
     * @return Successful Operation
     */
    deleteUserLocalStore(cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/user/store";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processDeleteUserLocalStore(_response);
        });
    }
    processDeleteUserLocalStore(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * check the eligibility of the user for billing
     * @return Successful Operation
     */
    getEligibility(cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/billing/eligibilities";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetEligibility(_response);
        });
    }
    processGetEligibility(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("request params are invalid", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Get the invoices related to user and subscription
     * @param subscription_id the subscription id for which invoices are to be fetched
     * @param size (optional) the number of invoices to return in the response
     * @param last_id (optional) the last_id parameter sent by the previous response. It will be used in pagination. you can skip it in first request.
     * @return Successful Operation
     */
    getAllInvoices(subscription_id, size, last_id, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/billing/invoices?";
        if (subscription_id === undefined || subscription_id === null)
            throw new Error("The parameter 'subscription_id' must be defined and cannot be null.");
        else
            url_ += "subscription_id=" + encodeURIComponent("" + subscription_id) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (last_id === null)
            throw new Error("The parameter 'last_id' cannot be null.");
        else if (last_id !== undefined)
            url_ += "last_id=" + encodeURIComponent("" + last_id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetAllInvoices(_response);
        });
    }
    processGetAllInvoices(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("request params are invalid", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * pay an invoice
     * @param id identification number of the invoice
     * @return Successful Operation
     */
    payInvoice(id, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/billing/invoices/{id}/pay";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processPayInvoice(_response);
        });
    }
    processPayInvoice(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid invoice id or missing invoice id", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Plan not found with requested id", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * download invoice pdf
     * @param id identification number of the invoice
     * @return Successful Operation
     */
    downloadInvoice(id, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/billing/invoices/{id}/download";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processDownloadInvoice(_response);
        });
    }
    processDownloadInvoice(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid invoice id or missing invoice id", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Plan not found with requested id", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Get All available products for a product/service
     * @return Successful Operation
     */
    getAllProducts(cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/billing/products";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetAllProducts(_response);
        });
    }
    processGetAllProducts(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Get All purchased products for a user
     * @return Successful Operation
     */
    getPurchasedProducts(cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/billing/products/my";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetPurchasedProducts(_response);
        });
    }
    processGetPurchasedProducts(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Get a pricing product
     * @param id identification number of the product
     * @return Successful Operation
     */
    getPlan(id, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/billing/products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetPlan(_response);
        });
    }
    processGetPlan(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid product id or missing product id", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Plan not found with requested id", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Create setup intent for the user
     * @return Successful Operation
     */
    createSetupIntent(cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/billing/setup-intent";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processCreateSetupIntent(_response);
        });
    }
    processCreateSetupIntent(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Get cards for a user
     * @return Successful Operation
     */
    getCards(cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/billing/cards";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetCards(_response);
        });
    }
    processGetCards(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Add card to the user
     * @param body The requested field for adding a card
     * @return Successful Operation
     */
    addCard(body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/billing/cards";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processAddCard(_response);
        });
    }
    processAddCard(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * get card using id
     * @param id identification number of the card
     * @return Successful Operation
     */
    getCard(id, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/billing/cards/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetCard(_response);
        });
    }
    processGetCard(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Card not found", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * get card using id
     * @param id identification number of the card
     * @return Successful Operation
     */
    deleteCard(id, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/billing/cards/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            url: url_,
            headers: {},
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processDeleteCard(_response);
        });
    }
    processDeleteCard(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Card not found", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * get default card
     * @return Successful Operation
     */
    getDefaultCard(cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/billing/cards/default";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetDefaultCard(_response);
        });
    }
    processGetDefaultCard(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Card not found", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * update default card
     * @param body The requested field for updating the default card
     * @return Successful Operation
     */
    updateDefaultCard(body, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/billing/cards/default";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processUpdateDefaultCard(_response);
        });
    }
    processUpdateDefaultCard(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Card not found", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * upgrade or downgrade the subscription
     * @param id identification number of the subscription
     * @param body The requested field for updating the subscription
     * @return Successful Operation
     */
    updateSubscription(id, body, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/billing/subscriptions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processUpdateSubscription(_response);
        });
    }
    processUpdateSubscription(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("subscription couldn\'t be updated", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Subscription not found with requested id", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Get the current active subscription of user for the given business
     * @return Successful Operation
     */
    getCurrentSubscription(cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/billing/subscriptions";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetCurrentSubscription(_response);
        });
    }
    processGetCurrentSubscription(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            return throwException("Free product does not found", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * cancel the current subscription of user
     * @param id id of the subscription to be cancelled
     * @return Successful Operation
     */
    cancelSubscription(id, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/billing/subscriptions/{id}/cancel";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processCancelSubscription(_response);
        });
    }
    processCancelSubscription(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("subscription cancellation not allowed", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("subscription or free product or business not found", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * checks if subscription can be updated
     * @param id id of the subscription to be cancelled
     * @param body The requested field for updating the subscription
     * @return Successful Operation
     */
    checkSubscriptionUpdate(id, body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/billing/subscriptions/{id}/check-update";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processCheckSubscriptionUpdate(_response);
        });
    }
    processCheckSubscriptionUpdate(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("subscription cancellation not allowed", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("subscription or free product or business not found", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Get the referral code for the given user
     * @return Successful Operation
     */
    getReferralCode(cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/billing/referral";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetReferralCode(_response);
        });
    }
    processGetReferralCode(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Claim the referral code
     * @param body The request body for claiming the referral bonus
     * @return Successfully claimed the referral bonus
     */
    confirmReferralCode(body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/billing/referral";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processConfirmReferralCode(_response);
        });
    }
    processConfirmReferralCode(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("The maximum usage for the given referral code is exhausted. you are not allowed to use the referral code any more", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Referral code does not exist", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("The referral code has already been claimed by the user", status, _responseText, _headers, result409);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * List buckets
     * @param type (optional)
     * @param public_access (optional)
     * @return Successful Operation,
     */
    listBuckets(type, public_access, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/buckets?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            if (type) {
                url_ += "type=";
                type.forEach((item, i, arr) => {
                    url_ += encodeURIComponent("" + item);
                    if (i < arr.length - 1) {
                        url_ += ",";
                    }
                });
                url_ += "&";
            }
        if (public_access === null)
            throw new Error("The parameter 'public_access' cannot be null.");
        else if (public_access !== undefined)
            if (public_access) {
                url_ += "public_access=";
                public_access.forEach((item, i, arr) => {
                    url_ += encodeURIComponent("" + item);
                    if (i < arr.length - 1) {
                        url_ += ",";
                    }
                });
                url_ += "&";
            }
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processListBuckets(_response);
        });
    }
    processListBuckets(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid or missing authorization token", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("no buckets was found", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Create bucket
     * @param body information to update pin
     * @return Successful Operation
     */
    createBucket(body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/buckets";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processCreateBucket(_response);
        });
    }
    processCreateBucket(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Data that was provider for modification is incorrect", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Bucket is not found", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Get a summary of the users buckets
     * @return Successful Operation,
     */
    bucketsSummary(cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/buckets/summary";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processBucketsSummary(_response);
        });
    }
    processBucketsSummary(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("No buckets found", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Get bucket by ID
     * @return Successful Operation,
     */
    getBucket(bucket_id, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/buckets/{bucket_id}";
        if (bucket_id === undefined || bucket_id === null)
            throw new Error("The parameter 'bucket_id' must be defined.");
        url_ = url_.replace("{bucket_id}", encodeURIComponent("" + bucket_id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetBucket(_response);
        });
    }
    processGetBucket(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid or missing authorization token", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("bucket was not found", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Update bucket
     * @param body Updated Bucket details
     * @return Successful Operation
     */
    updateBucket(bucket_id, body, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/buckets/{bucket_id}";
        if (bucket_id === undefined || bucket_id === null)
            throw new Error("The parameter 'bucket_id' must be defined.");
        url_ = url_.replace("{bucket_id}", encodeURIComponent("" + bucket_id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processUpdateBucket(_response);
        });
    }
    processUpdateBucket(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Bucket is not found", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * remove bucket that's shared with the user
     * @return Successful Operation,
     */
    removeBucket(bucket_id, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/buckets/{bucket_id}";
        if (bucket_id === undefined || bucket_id === null)
            throw new Error("The parameter 'bucket_id' must be defined.");
        url_ = url_.replace("{bucket_id}", encodeURIComponent("" + bucket_id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            url: url_,
            headers: {},
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processRemoveBucket(_response);
        });
    }
    processRemoveBucket(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid or missing authorization token", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("bucket was not found", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Info
     * @return Successful Operation
     */
    getBucketInfo(bucket_id, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/bucket/{bucket_id}/info";
        if (bucket_id === undefined || bucket_id === null)
            throw new Error("The parameter 'bucket_id' must be defined.");
        url_ = url_.replace("{bucket_id}", encodeURIComponent("" + bucket_id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetBucketInfo(_response);
        });
    }
    processGetBucketInfo(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid or missing apikey or secretkey", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("File Store do not exists for the provided user identifier", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("File of directory name in conflict with existing structure", status, _responseText, _headers, result409);
        }
        else if (status === 503) {
            const _responseText = response.data;
            let result503 = null;
            let resultData503 = _responseText;
            result503 = JSON.parse(resultData503);
            return throwException("Drive Service is not inilialized", status, _responseText, _headers, result503);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Bucket users
     * @return Successful Operation
     */
    getBucketUsers(bucket_id, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/bucket/{bucket_id}/users";
        if (bucket_id === undefined || bucket_id === null)
            throw new Error("The parameter 'bucket_id' must be defined.");
        url_ = url_.replace("{bucket_id}", encodeURIComponent("" + bucket_id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetBucketUsers(_response);
        });
    }
    processGetBucketUsers(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid or missing apikey or secretkey", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("File Store do not exists for the provided user identifier", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("File of directory name in conflict with existing structure", status, _responseText, _headers, result409);
        }
        else if (status === 503) {
            const _responseText = response.data;
            let result503 = null;
            let resultData503 = _responseText;
            result503 = JSON.parse(resultData503);
            return throwException("Drive Service is not inilialized", status, _responseText, _headers, result503);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Check Upload
     * @param body files details containing paths
     * @return Successful Operation
     */
    checkUploadBucketObjects(bucket_id, body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/bucket/{bucket_id}/check-upload";
        if (bucket_id === undefined || bucket_id === null)
            throw new Error("The parameter 'bucket_id' must be defined.");
        url_ = url_.replace("{bucket_id}", encodeURIComponent("" + bucket_id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processCheckUploadBucketObjects(_response);
        });
    }
    processCheckUploadBucketObjects(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid or missing apikey or secretkey", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("File Store or File do not exists for the provided user identifier", status, _responseText, _headers, result404);
        }
        else if (status === 503) {
            const _responseText = response.data;
            let result503 = null;
            let resultData503 = _responseText;
            result503 = JSON.parse(resultData503);
            return throwException("Drive service is not inilialized", status, _responseText, _headers, result503);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Upload
     * @param file (optional)
     * @param path (optional)
     * @param deal_duration (optional)
     * @param replication (optional)
     * @return Successful Operation
     */
    uploadBucketObjects(bucket_id, file, path, deal_duration, replication, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/bucket/{bucket_id}/upload";
        if (bucket_id === undefined || bucket_id === null)
            throw new Error("The parameter 'bucket_id' must be defined.");
        url_ = url_.replace("{bucket_id}", encodeURIComponent("" + bucket_id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            file.forEach(item_ => content_.append("file", item_.data, item_.fileName ? item_.fileName : "file"));
        if (path === null || path === undefined)
            throw new Error("The parameter 'path' cannot be null.");
        else
            content_.append("path", path.toString());
        if (deal_duration !== null && deal_duration !== undefined)
            content_.append("deal_duration", deal_duration.toString());
        if (replication !== null && replication !== undefined)
            content_.append("replication", replication.toString());
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processUploadBucketObjects(_response);
        });
    }
    processUploadBucketObjects(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid or missing apikey or secretkey", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("File Store do not exists for the provided user identifier", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("file of directory name in conflict with existing structure", status, _responseText, _headers, result409);
        }
        else if (status === 503) {
            const _responseText = response.data;
            let result503 = null;
            let resultData503 = _responseText;
            result503 = JSON.parse(resultData503);
            return throwException("drive service is not inilialized", status, _responseText, _headers, result503);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * update
     * @param bucket_id bucket identifier
     * @param file (optional)
     * @param path (optional)
     * @param deal_duration (optional)
     * @param replication (optional)
     * @return Successful Operation
     */
    update(bucket_id, file, path, deal_duration, replication, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/bucket/{bucket_id}/upload";
        if (bucket_id === undefined || bucket_id === null)
            throw new Error("The parameter 'bucket_id' must be defined.");
        url_ = url_.replace("{bucket_id}", encodeURIComponent("" + bucket_id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            file.forEach(item_ => content_.append("file", item_.data, item_.fileName ? item_.fileName : "file"));
        if (path === null || path === undefined)
            throw new Error("The parameter 'path' cannot be null.");
        else
            content_.append("path", path.toString());
        if (deal_duration !== null && deal_duration !== undefined)
            content_.append("deal_duration", deal_duration.toString());
        if (replication !== null && replication !== undefined)
            content_.append("replication", replication.toString());
        let options_ = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processUpdate(_response);
        });
    }
    processUpdate(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid or missing apikey or secretkey", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("File does not exists", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("file of directory name in conflict with existing structure", status, _responseText, _headers, result409);
        }
        else if (status === 503) {
            const _responseText = response.data;
            let result503 = null;
            let resultData503 = _responseText;
            result503 = JSON.parse(resultData503);
            return throwException("drive service is not inilialized", status, _responseText, _headers, result503);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Rename/Move File/Folder
     * @param body file path
     * @return Successful Operation
     */
    moveBucketObjects(bucket_id, body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/bucket/{bucket_id}/mv";
        if (bucket_id === undefined || bucket_id === null)
            throw new Error("The parameter 'bucket_id' must be defined.");
        url_ = url_.replace("{bucket_id}", encodeURIComponent("" + bucket_id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processMoveBucketObjects(_response);
        });
    }
    processMoveBucketObjects(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid or missing apikey or secretkey", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("File Store or File Name do not exists for the provided user", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("file of directory name in conflict with existing structure", status, _responseText, _headers, result409);
        }
        else if (status === 503) {
            const _responseText = response.data;
            let result503 = null;
            let resultData503 = _responseText;
            result503 = JSON.parse(resultData503);
            return throwException("drive service is not inilialized", status, _responseText, _headers, result503);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Get File Info
     * @param body file path
     * @return Successful Operation
     */
    getBucketObjectInfo(bucket_id, body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/bucket/{bucket_id}/file";
        if (bucket_id === undefined || bucket_id === null)
            throw new Error("The parameter 'bucket_id' must be defined.");
        url_ = url_.replace("{bucket_id}", encodeURIComponent("" + bucket_id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetBucketObjectInfo(_response);
        });
    }
    processGetBucketObjectInfo(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("File Store or File itself do not exists for the provided user identifier", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid or missing apikey or secretkey", status, _responseText, _headers);
        }
        else if (status === 503) {
            const _responseText = response.data;
            let result503 = null;
            let resultData503 = _responseText;
            result503 = JSON.parse(resultData503);
            return throwException("drive service is not inilialized", status, _responseText, _headers, result503);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Delete File/Folder
     * @param body array of object paths
     * @return Successful Operation
     */
    removeBucketObject(bucket_id, body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/bucket/{bucket_id}/rm";
        if (bucket_id === undefined || bucket_id === null)
            throw new Error("The parameter 'bucket_id' must be defined.");
        url_ = url_.replace("{bucket_id}", encodeURIComponent("" + bucket_id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processRemoveBucketObject(_response);
        });
    }
    processRemoveBucketObject(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid or missing apikey or secretkey", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("File Store or File do not exists for the provided user identifier", status, _responseText, _headers, result404);
        }
        else if (status === 503) {
            const _responseText = response.data;
            let result503 = null;
            let resultData503 = _responseText;
            result503 = JSON.parse(resultData503);
            return throwException("Drive service is not inilialized", status, _responseText, _headers, result503);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * List Files
     * @param body file path
     * @return Successful Operation
     */
    getBucketObjectChildrenList(bucket_id, body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/bucket/{bucket_id}/ls";
        if (bucket_id === undefined || bucket_id === null)
            throw new Error("The parameter 'bucket_id' must be defined.");
        url_ = url_.replace("{bucket_id}", encodeURIComponent("" + bucket_id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetBucketObjectChildrenList(_response);
        });
    }
    processGetBucketObjectChildrenList(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid or missing apikey or secretkey", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("File Store do not exists for the provided user identifier", status, _responseText, _headers, result404);
        }
        else if (status === 503) {
            const _responseText = response.data;
            let result503 = null;
            let resultData503 = _responseText;
            result503 = JSON.parse(resultData503);
            return throwException("drive service is not inilialized", status, _responseText, _headers, result503);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Create Folder
     * @param body directory path
     * @return Successful Operation
     */
    addBucketDirectory(bucket_id, body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/bucket/{bucket_id}/mkdir";
        if (bucket_id === undefined || bucket_id === null)
            throw new Error("The parameter 'bucket_id' must be defined.");
        url_ = url_.replace("{bucket_id}", encodeURIComponent("" + bucket_id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processAddBucketDirectory(_response);
        });
    }
    processAddBucketDirectory(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid or missing apikey or secretkey", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("File Store do not exists for the provided user identifier", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("file of directory name in conflict with existing structure", status, _responseText, _headers, result409);
        }
        else if (status === 503) {
            const _responseText = response.data;
            let result503 = null;
            let resultData503 = _responseText;
            result503 = JSON.parse(resultData503);
            return throwException("drive service is not inilialized", status, _responseText, _headers, result503);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Share Bucket
     * @param body directory path
     * @return Successful Operation
     */
    shareBucket(bucket_id, body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/bucket/{bucket_id}/share";
        if (bucket_id === undefined || bucket_id === null)
            throw new Error("The parameter 'bucket_id' must be defined.");
        url_ = url_.replace("{bucket_id}", encodeURIComponent("" + bucket_id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processShareBucket(_response);
        });
    }
    processShareBucket(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid or missing apikey or secretkey", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("File Store do not exists for the provided user identifier", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("file of directory name in conflict with existing structure", status, _responseText, _headers, result409);
        }
        else if (status === 503) {
            const _responseText = response.data;
            let result503 = null;
            let resultData503 = _responseText;
            result503 = JSON.parse(resultData503);
            return throwException("drive service is not inilialized", status, _responseText, _headers, result503);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Download file from bucket
     * @param body file path
     * @return Successful Operation
     */
    getBucketObjectContent(bucket_id, body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/bucket/{bucket_id}/download";
        if (bucket_id === undefined || bucket_id === null)
            throw new Error("The parameter 'bucket_id' must be defined.");
        url_ = url_.replace("{bucket_id}", encodeURIComponent("" + bucket_id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetBucketObjectContent(_response);
        });
    }
    processGetBucketObjectContent(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("File Store do not exists for the provided user identifier", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid or missing Authentication token", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("File with such CID does not exists", status, _responseText, _headers, result404);
        }
        else if (status === 503) {
            const _responseText = response.data;
            let result503 = null;
            let resultData503 = _responseText;
            result503 = JSON.parse(resultData503);
            return throwException("drive service is not inilialized", status, _responseText, _headers, result503);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Tree of the File system directories
     * @return Successful Operation
     */
    getBucketDirectoriesTree(bucket_id, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/bucket/{bucket_id}/tree";
        if (bucket_id === undefined || bucket_id === null)
            throw new Error("The parameter 'bucket_id' must be defined.");
        url_ = url_.replace("{bucket_id}", encodeURIComponent("" + bucket_id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetBucketDirectoriesTree(_response);
        });
    }
    processGetBucketDirectoriesTree(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("File Store do not exists for the provided user identifier", status, _responseText, _headers, result404);
        }
        else if (status === 503) {
            const _responseText = response.data;
            let result503 = null;
            let resultData503 = _responseText;
            result503 = JSON.parse(resultData503);
            return throwException("drive service is not initialized", status, _responseText, _headers, result503);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Get Pin Info
     * @param cid (optional) Return pin objects responsible for pinning the specified CID(s); be aware that using longer hash functions introduces further constraints on the number of CIDs that will fit under the limit of 2000 characters per URL  in browser contexts
     * @param name (optional) Return pin objects with specified name (by default a case-sensitive, exact match)
     * @param match (optional) This query parameter is used to define various matching strategy to match the name. If client does not specify the value, it will be consider exact
     * @param status (optional) Return pin objects for pins with the specified status
     * @param after (optional) Return results created (queued) after provided timestamp
     * @param before (optional) Return results created (queued) before provided timestamp
     * @param limit (optional) Max records to return
     * @param meta (optional) Return pin objects that match specified metadata keys passed as a string representation of a JSON object; when implementing a client library, make sure the parameter is URL-encoded to ensure safe transport
     * @param sortOrder (optional) Specifies the sort order of the pins by created at. By default it will be in descending order of created at timestamp. i.e latest first.
     * @return Successful Operation,
     */
    listPins(cid, name, match, status, after, before, limit, meta, sortOrder, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/pins?";
        if (cid === null)
            throw new Error("The parameter 'cid' cannot be null.");
        else if (cid !== undefined)
            if (cid) {
                url_ += "cid=";
                cid.forEach((item, i, arr) => {
                    url_ += encodeURIComponent("" + item);
                    if (i < arr.length - 1) {
                        url_ += ",";
                    }
                });
                url_ += "&";
            }
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (match === null)
            throw new Error("The parameter 'match' cannot be null.");
        else if (match !== undefined)
            url_ += "match=" + encodeURIComponent("" + match) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            if (status) {
                url_ += "status=";
                status.forEach((item, i, arr) => {
                    url_ += encodeURIComponent("" + item);
                    if (i < arr.length - 1) {
                        url_ += ",";
                    }
                });
                url_ += "&";
            }
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent(after ? "" + after.toJSON() : "") + "&";
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent(before ? "" + before.toJSON() : "") + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (meta === null)
            throw new Error("The parameter 'meta' cannot be null.");
        else if (meta !== undefined)
            url_ += "meta=" + encodeURIComponent("" + meta) + "&";
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "sortOrder=" + encodeURIComponent("" + sortOrder) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processListPins(_response);
        });
    }
    processListPins(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Error response (Bad request)", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid or missing apikey or secretkey", status, _responseText, _headers);
        }
        else if (status === 413) {
            const _responseText = response.data;
            let result413 = null;
            let resultData413 = _responseText;
            result413 = JSON.parse(resultData413);
            return throwException("Max limit of returned pin status is 1000 and min is 1", status, _responseText, _headers, result413);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Add pin object
     * @return Successful response
     */
    addPin(body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/pins";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processAddPin(_response);
        });
    }
    processAddPin(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Error response (Bad request)", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid or missing apikey or secretkey", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Delete Pin
     * @return Successful Operation
     */
    deletePin(requestid, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/pins/{requestid}";
        if (requestid === undefined || requestid === null)
            throw new Error("The parameter 'requestid' must be defined.");
        url_ = url_.replace("{requestid}", encodeURIComponent("" + requestid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            url: url_,
            headers: {},
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processDeletePin(_response);
        });
    }
    processDeletePin(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid or missing apikey or secretkey", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("No pins with Cid was found", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Replace pin object
     * @return Successful Operation
     */
    editPin(body, requestid, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/pins/{requestid}";
        if (requestid === undefined || requestid === null)
            throw new Error("The parameter 'requestid' must be defined.");
        url_ = url_.replace("{requestid}", encodeURIComponent("" + requestid));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processEditPin(_response);
        });
    }
    processEditPin(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Error response (Bad request)", status, _responseText, _headers, result400);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("No pins with Cid was found", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("Modification is not possible since new data in conflict with existing ones", status, _responseText, _headers, result409);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Get pin object
     * @return Successful response
     */
    getPin(requestid, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/pins/{requestid}";
        if (requestid === undefined || requestid === null)
            throw new Error("The parameter 'requestid' must be defined.");
        url_ = url_.replace("{requestid}", encodeURIComponent("" + requestid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetPin(_response);
        });
    }
    processGetPin(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("No pins with Cid was found", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * retrieve asks
     * @return Successful Operation
     */
    getAsks(cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/powergate/asks";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetAsks(_response);
        });
    }
    processGetAsks(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("invalid or missing bearer token", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * retrieve deals
     * @param direction filter by deal type
     * @param only (optional) filter by deal status
     * @return Successful Operation
     */
    getDeals(direction, only, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/powergate/deals?";
        if (direction === undefined || direction === null)
            throw new Error("The parameter 'direction' must be defined and cannot be null.");
        else
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (only === null)
            throw new Error("The parameter 'only' cannot be null.");
        else if (only !== undefined)
            url_ += "only=" + encodeURIComponent("" + only) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetDeals(_response);
        });
    }
    processGetDeals(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("no direction query parameter was provided in a request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("invalid or missing bearer tokeng", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * retrieve faults
     * @return Successful Operation
     */
    getFaults(cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/powergate/faults";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetFaults(_response);
        });
    }
    processGetFaults(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("no direction query parameter was provided in a request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("invalid or missing bearer token", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * retrieve miners
     * @return Successful Operation
     */
    getMiners(cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/powergate/miners";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetMiners(_response);
        });
    }
    processGetMiners(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("invalid or missing bearer token", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * retrieve peers
     * @return Successful Operation
     */
    getPeers(cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/powergate/peers";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetPeers(_response);
        });
    }
    processGetPeers(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("invalid or missing bearer token", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * retrieve top miners by reputation
     * @param limit words go here
     * @return Successful Operation
     */
    getTopMiners(limit, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/powergate/reputation/topminers?";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetTopMiners(_response);
        });
    }
    processGetTopMiners(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("invalid or missing bearer token", status, _responseText, _headers);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("provided limit is invalid", status, _responseText, _headers, result429);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * create sharing nonce
     * @param body request body attributes to share a file
     * @return Successful Operation
     */
    createNonce(body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/sharing/nonces";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processCreateNonce(_response);
        });
    }
    processCreateNonce(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Get all the active nonces for the specific user
     * @return Successful Operation
     */
    getAllNonces(cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/sharing/nonces";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processGetAllNonces(_response);
        });
    }
    processGetAllNonces(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid authentication token", status, _responseText, _headers);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * verify the sharing link
     * @param body request body attributes to verify the link
     * @return successfully verified the sharing link
     */
    verifyNonce(body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/sharing/verify";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processVerifyNonce(_response);
        });
    }
    processVerifyNonce(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("error in the request structure parsing", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("denied doing the specific operation", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("the resource not found", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * revoke the sharing nonce
     * @return Successful Operation
     */
    revokeNonce(id, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/sharing/nonces/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            url: url_,
            headers: {},
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processRevokeNonce(_response);
        });
    }
    processRevokeNonce(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("current user or nonce id not found", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Invalid authentication token", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("you dont have permission to revoke the nonce", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("the nonce could not be found", status, _responseText, _headers, result404);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * get the validity of the nonce
     * @return Successful Operation
     */
    isNonceValid(id, cancelToken, onDownloadProgress) {
        let url_ = this.baseUrl + "/sharing/nonces/{id}/validate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processIsNonceValid(_response);
        });
    }
    processIsNonceValid(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Search Files
     * @param body Search query object
     * @return successful operation
     */
    searchFiles(body, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/search/query";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processSearchFiles(_response);
        });
    }
    processSearchFiles(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Bad Request Binding", status, _responseText, _headers, result400);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * Upload NFT Metadata
     * @param body NFT Data to be uploaded
     * @param hash (optional) -> The hash function to use on generating cid that will be returned on response. If invalid or no option provided it will use default hash(sha2-256).
     * @return Successful Operation
     */
    uploadNFT(body, hash, cancelToken, onDownloadProgress, onUploadProgress) {
        let url_ = this.baseUrl + "/nft?";
        if (hash === null)
            throw new Error("The parameter 'hash' cannot be null.");
        else if (hash !== undefined)
            url_ += "hash=" + encodeURIComponent("" + hash) + "&";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = formDataHelper_1.formDataHelper(body);
        const encoder = new form_data_encoder_1.FormDataEncoder(content_);
        const headers = browser_or_node_1.isNode ? encoder.headers : undefined;
        let options_ = {
            data: browser_or_node_1.isNode ? stream_1.Readable.from(encoder) : content_,
            method: "POST",
            url: url_,
            headers: Object.assign(Object.assign({}, headers), { "Accept": "application/json" }),
            cancelToken,
            onDownloadProgress,
            onUploadProgress
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.processUploadNFT(_response);
        });
    }
    processUploadNFT(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            return throwException("Invalid or missing apikey or secretkey", status, _responseText, _headers);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("File Store do not exists for the provided user identifier", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("file of directory name in conflict with existing structure", status, _responseText, _headers, result409);
        }
        else if (status === 503) {
            const _responseText = response.data;
            let result503 = null;
            let resultData503 = _responseText;
            result503 = JSON.parse(resultData503);
            return throwException("drive service is not inilialized", status, _responseText, _headers, result503);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("server error", status, _responseText, _headers, resultdefault);
        }
    }
}
exports.FilesApiClient = FilesApiClient;
class FilesApiException extends Error {
    constructor(message, status, response, headers, result) {
        super();
        this.isFilesApiException = true;
        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }
    static isFilesApiException(obj) {
        return obj.isFilesApiException === true;
    }
}
exports.FilesApiException = FilesApiException;
function throwException(message, status, response, headers, result) {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new FilesApiException(message, status, response, headers, null);
}
function isAxiosError(obj) {
    return obj && obj.isAxiosError === true;
}
/**
 * Configuration class needed in base class.
 * The config is provided to the API client at initialization time.
 * API clients inherit from #AuthorizedApiBase and provide the config.
 */
class IConfig {
}
exports.IConfig = IConfig;
//# sourceMappingURL=FilesApiClient.js.map